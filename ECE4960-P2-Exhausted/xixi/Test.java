/**
 * Test.java, ECE4960-P2
 * Created by Yuan He(yh772) on 2018/03/06
 * Platform: Java 8, Eclipse, MacOS
 * Copyright Â© 2018 Yuan He. All rights reserved.
 */
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;

public class Test {

	/* The testing inputs */
	// The "mat1" SparseMatrix
	static String filePath1[] = {"value.csv", "rowPtr.csv", "colInd.csv"};
	static final SparseMatrix mat1 = Test.readMatrix(filePath1);

	// An all-1 SparseMatrix, with a rank of 500 (input files generated by Python)
	static String filePath2[] = {"value1.csv", "rowPtr1.csv", "colInd1.csv"};
	static final SparseMatrix All1 = Test.readMatrix(filePath2);

	// An all-1 diagonal SparseMatrix, with a rank of 5000 (input files generated by Python)
	static String filePath3[] = {"value2.csv", "rowPtr2.csv", "colInd2.csv"};
	static final SparseMatrix dia1 = Test.readMatrix(filePath3);

	// An all-2 diagonal SparseMatrix, with a rank of 5000 (input files generated by Python)
	static String filePath4[] = {"value3.csv", "rowPtr2.csv", "colInd2.csv"};
	static final SparseMatrix dia2 = Test.readMatrix(filePath4);

	// A known full matrix, and its corresponding sparse matrix
	static double full[][] = {{1,2,0,0,3},{4,5,6,0,0},{0,7,8,0,9},{0,0,0,10,0},{11,0,0,0,12}};
	static double value[] = {1,2,3,4,5,6,7,8,9,10,11,12};
	static int rowPtr[] = {0,3,6,9,10,12};
	static int colInd[] = {0,1,4,0,1,2,1,2,4,3,0,4};
	static SparseMatrix sp = new SparseMatrix(value,rowPtr,colInd) ;

	// The output report's path
	static String reportPath = null;

	/* The Testing functions */
	/**Function: Test SparseMatrix.poduct()
	 * Parameter: None
	 * Return: None*/
	public static void productTest() {
		//Output this section's title
		output("\n\n  SparseMatrix.product() Testing, WITHOUT GROUND-TRUTH: ");

		/* Verify the function's input invariant:
		 * Check: whether an error is thrown to terminate the program, when the input violates
		 * the function invariants of "SparseMatrix's rank == Vector's length" */
		inputTest("productTest");

		/* Verify the function's output correctness, without knowing the ground truth*/ 
		/* Check 1: when Vector is an all-1, check whether |A*X1 - X2| == 0, 
		 * where Vector x2 has each element being the sum of A's row, and A is an arbitrary Sparse Matrix*/ 

		// Sum up each row of the matrix == rowSum
		Vector rowSum = new Vector(mat1.rank);
		for(int i=0; i<mat1.rank; i++) {
			for(int j=0; j<mat1.rank; j++) {rowSum.v[i] += mat1.retrieveElement(i, j)[1];}
		}

		// Create a Vector with its values all 1
		Vector all1 = new Vector(mat1.rank);
		for(int i=0; i<mat1.rank; i++) {all1.v[i] = 1;}

		// Create a Vector containing the product of matrix * Vector-all1
		Vector Ax1 = mat1.product(all1);

		// Output whether the product is correct (by telling whether ||rowSum - Ax1|| == 0)
		output("\n	"+ (vecNorm(rowSum, Ax1)==0 ? "PASSED" : "FAILED") +
				": Function's output correctness testing! By checking ||mat1RowSum - mat1 * All1Vector|| == 0");

		/* Check 2: when SparseMatrix is an all-1, check whether |A*X1 - X2| == 0, 
		 * where Vector X2 has each element being the sum of Vector X1's all element, and X1 is an arbitrary Vector*/ 

		Vector X1 = new Vector(All1.rank);
		Vector X2 = new Vector(All1.rank);
		double X1Sum = (1+All1.rank)*All1.rank / 2;
		for(int i=1; i<All1.rank+1; i++) {
			X1.v[i-1] = i;
			X2.v[i-1] = X1Sum;
		}

		// The product of all-1 matrix and Vector X1
		Vector All1xX1 = All1.product(X1); 

		// Output whether the product is correct (by telling whether ||VectorSum - All1Matrix x Vector|| == 0)
		output("\n	"+ (vecNorm(All1xX1, X2)==0 ? "PASSED" : "FAILED") +
				": Function's output correctness testing! By checking ||VectorColSum - All1Matrix * Vector|| == 0");
	}

	/**Function: Test SparseMatrix.leftMult()
	 * Parameter: None
	 * Return: None*/
	public static void leftMultTest() {
		// Output this section's title
		output("\n\n  SparseMatrix.leftMult() Testing, WITHOUT GROUND-TRUTH: ");

		/* Verify the function's input invariant:
		 * Check: whether an error is thrown to terminate the program, when the input violates
		 * the function invariants of "SparseMatrix1's rank == SparseMatrix2's rank" */
		inputTest("leftMultTest");

		/* Verify the function's output correctness, without knowing the ground truth*/ 
		/* Check: when left diagonal matrix sp1's elements are all-1, sp1 left-multiply any 
		 * SparseMatrix sp2's product would equal sp2 itself*/ 

		// Product of diagonal matrix and Mat1
		SparseMatrix diaProduct = dia1.leftMult(mat1);

		// Output whether the product is correct (by telling whether ||mat1 - MatrixDiagonal x Vector|| == 0)
		output("\n	"+ (matNorm(diaProduct, mat1)==0 ? "PASSED" : "FAILED") 
				+ ": Function's output correctness testing! By checking ||mat1 - MatrixDiagonal1 * mat1|| == 0");
	}


	/**Function: Test SparseMatrix.add()
	 * Parameter: None
	 * Return: None*/
	public static void addTest() {
		// Output this section's title
		output("\n\n  SparseMatrix.add() Testing, WITHOUT GROUND-TRUTH: ");

		/* Verify the function's input invariant:
		 * Check: whether an error is thrown to terminate the program, when the input violates
		 * the function invariants of "SparseMatrix1's rank == SparseMatrix2's rank" */;
		inputTest("addTest");

		/* Verify the function's output correctness, without knowing the ground truth*/ 
		/* Check1: let "dia2" be an all-2 diagonal matrix, then Matrix1 + Matrix1 = dia2 * Martix1, 
		 * under the condition that leftMultTest() is passed. */ 

		// Sum of mat1 and Mat1
		SparseMatrix sum = mat1.add(mat1,1);

		// Output whether the sum is correct (by telling whether ||(mat1 + mat1*1) - (dia2 * mat1)|| == 0)
		output("\n	"+ (matNorm(sum, dia2.leftMult(mat1))==0 ? "PASSED" : "FAILED") 
				+ ": Function's output correctness testing! By checking ||(mat1 + mat1*1) - (MatrixDiagonal2 * mat1)|| == 0");

		/* Check2: if Matrix1 + Matrix1*(-1) = 0 */

		// Product of diagonal matrix and Mat1
		SparseMatrix sub = mat1.add(mat1,-1);

		// Output whether the sum is correct (by telling whether ||mat1 + mat1*(-1)|| == 0)
		output("\n	"+ (matNorm(sub)==0 ? "PASSED" : "FAILED") 
				+ ": Function's output correctness testing! By checking ||mat1 + mat1*(-1)|| == 0");
	}

	/**Function: Test SparseMatrix.retrieveElement()
	 * Parameter: None
	 * Return: None*/
	public static void retrieveTest() {
		// Output this section's title
		output("\n\n  SparseMatrix.retrieveElement() Testing, KNOWING GROUND-TRUTH & WILKINSON: ");

		/* Verify the function's input invariant:
		 * Check: whether an error is thrown to terminate the program, when the input violates
		 * the function invariants that the index should be in-bound */
		inputTest("retrieveTest");

		/* Verify the function's output correctness, knowing the ground truth,
		 * compare the retrieving output between full matrix and sparse matrix*/ 

		// Output whether retrieving is correctly done with Wilkinson principal
		output("\n	"+ (compareMtx(full, sp) ? "PASSED" : "FAILED") 
				+ ": Function's output correctness testing! "
				+ "By comparing the retrieved elements with SparseMatrix's and fullMatrix's retrieving methods");
	}

	

	/**Function: Test SparseMatrix.matrixSetter()
	 * Parameter: None
	 * Return: None*/
	public static void matrixSetterTest() {
		// Output this section's title
		output("\n\n  SparseMatrix.matrixSetterTest() Testing, KNOWING GROUND-TRUTH & WILKINSON: ");

		/* Verify the function's input invariant:
		 * Check: whether an error is thrown to terminate the program, when the input violates
		 * the function invariants that the index should be in-bound */
		inputTest("matrixSetterTest");

		/* Verify the function's output correctness, knowing the ground truth,
		 * Check1: add SparseMatrix sp's elements to an empty SparseMatrix from scratch, 
		 * and compare it with an equivalent known full Matrix, considering that 
		 * SparseMatrix.retrieveElement() passed the test*/ 

		// Create an empty sparse matrix
		SparseMatrix sp2 = new SparseMatrix(sp.rank);
		for(int i=0; i<sp2.rank; i++) {
			for(int j=0; j<sp2.rank; j++) {
				sp2.matrixSetter(i, j, sp.retrieveElement(i, j)[1]);
			}
		}

		// Output whether the matrix setter created from a full matrix has the same data structure as the equivalent(to that full matrix) sparse matrix
		output("\n	"+ (compareMtx(full, sp2) ? "PASSED" : "FAILED") + ": Function's output correctness testing! "
				+ "By comparing the matrix created by matrixSetter() from another sparse matrix, and an equivalent full matrix");


		/* Check2: change values this newly created sparse matrix, 
		 * and compare it with the known data structure*/
	}

	/**Function: Test mat1 with the Jacobi solver*/
	public static void mat1Test() {
		// Record the start time for time-counting this method
		long startTime= System.nanoTime();

		// Initiate vectors b
		double bb1[] = new double[mat1.rank];
		double bb2[] = new double[mat1.rank];
		double bb3[] = new double[mat1.rank];
		for(int i=0; i<mat1.rank; i++) {
			bb1[i] = 0.0;
			bb2[i] = 0.0;
			bb3[i] = 1.0;
		}
		bb1[0] = 1.0;
		bb2[4] = 1.0;
		Vector b1 = new Vector(bb1);
		Vector b2 = new Vector(bb2);
		Vector b3 = new Vector(bb3);

		//		double value[] = {-4,1,1,4,-4,1,1,-4,1,1,-4,1,1,1,-4};
		//		int rowPtr[] = {0,3,6,9,12,15};
		//		int colInd[] = {0,1,4,0,1,2,1,2,3,2,3,4,0,3,4};
		//		SparseMatrix sp = new SparseMatrix(value, rowPtr, colInd);
		//
		//		double bb[] = {1,0,0,0,0};
		//		Vector b1 = new Vector(bb);

		//		double a[] = sp.retrieve(1, 0);
		//		System.out.println(a[0]+"   "+a[1]);

		System.out.println("\nTo converge, it took iteration times of "+Jacobi.solver(mat1, b1));
		System.out.println("\nTo converge, it took iteration times of "+Jacobi.solver(mat1, b2));
		System.out.println("\nTo converge, it took iteration times of "+Jacobi.solver(mat1, b3));

		// Record the end time for time-counting this method
		long endTime= System.nanoTime();
		System.out.println("\nComputational Time for soving mat1 with Jacobi Iterative Solver: "+(endTime-startTime)+" ns");
	}


	// Helper functions:
	
	
	/** Function: Creating assertion errors for each SparseMatrix Function's invariant violation,
	 * 			  and make sure that the assertion errors are thrown when there are violation
	 * Parameter: String funcName
	 * Return: void*/
	public static void inputTest(String funcName) {
		// The expected error message
		String error = null;
		
		// Containing the testing case
		int arr[] = new int[2];

		if(funcName.equals("productTest") || funcName.equals("leftMultTest") || funcName.equals("addTest")) {
			error = "Unmatched matrix sizes!";
			arr[0] = 5;
			arr[1] = 4;
		}
		else if(funcName.equals("retrieveTest") || funcName.equals("matrixSetterTest")) {
			error = "IndexOutOfBound!";
			arr[0] = 5;
			arr[1] = -1;
		}

		String I[] = new String[2];

		// Create an assertion error
		for(int i=0; i<arr.length; i++) {
			try {
				if(funcName.equals("productTest")) {new SparseMatrix(arr[i]).product(new Vector(arr[arr.length-1-i]));}
				else if(funcName.equals("leftMultTest")) {new SparseMatrix(arr[i]).leftMult(new SparseMatrix(arr[arr.length-1-i]));}
				else if(funcName.equals("addTest")) {new SparseMatrix(arr[i]).leftMult(new SparseMatrix(arr[arr.length-1-i]));}
				else if(funcName.equals("retrieveTest")) {sp.retrieveElement(arr[i], arr[i]);}
				else if(funcName.equals("matrixSetterTest")) {sp.matrixSetter(arr[i], arr[i], 0);}
			}

			// Assign the error message to String I[];
			catch(AssertionError e) {I[i] = e.getMessage();}
		}

		// Output whether the AssertionError is caught
		output("\n	"+ (I[0].equals(error) && I[1].equals(error) ? "PASSED" : "FAILED") 
				+ ": Function's input invariants verification testing!");
	}


	/**Function: Compare two matrixes, one is full, the other is sparse, return true on equivalent
	 * Parameter: double[][] full, SparseMatrix sp
	 * return : boolean*/
	public static boolean compareMtx(double[][] full, SparseMatrix sp) {
		int i,j = 0;
		for(i=0; i<sp.rank; i++) {
			for(j=0; j<sp.rank; j++) {
				if(full[i][j]!=sp.retrieveElement(i, j)[1])
					break;
			}
		}
		return i+j == 2*sp.rank;
	}

	/** Compute the second norm of two Vectors' difference*/
	public static double vecNorm(Vector A, Vector B) {
		// Make sure A and B are of the same size
		assert A.len == B.len;

		// Accumulate each the difference
		double err = 0;
		for(int i=0; i<A.len; i++) {	err += Math.pow(A.v[i] - B.v[i], 2);}

		// Return the second norm difference
		return Math.pow(err, 0.5);
	}

	/** Compute the second norm of two SparseMatrixes' difference*/
	public static double matNorm(SparseMatrix A, SparseMatrix B) {
		// Make sure A and B are of the same size
		assert A.rank == B.rank;

		// Accumulate each the difference
		double err = 0;
		for(int i=0; i<A.rank; i++) {	
			for(int j=0; j<A.rank; j++) {
				err += Math.pow(A.retrieveElement(i,j)[1] - B.retrieveElement(i,j)[1], 2);
			}
		}

		// Return the second norm difference
		return Math.pow(err, 0.5);
	}

	/** Compute the second norm of one SparseMatrixe*/
	public static double matNorm(SparseMatrix A) {
		// Accumulate each the difference
		double value = 0;
		for(int i=0; i<A.rank; i++) {	
			for(int j=0; j<A.rank; j++) {
				value += Math.pow(A.retrieveElement(i,j)[1],2);
			}
		}

		// Return the second norm difference
		return Math.pow(value, 0.5);
	}

	/** Create report*/
	public static void createFile(String filePath, String content) {
		reportPath = filePath;
		try {
			FileWriter fw = new FileWriter(filePath,true);
			fw.write(content);
			fw.close();
		} catch (IOException e) {
			System.out.println("writing failure" + e);
		}
	}

	/** Writing "content" into "filePath", for writing reports' purpose*/
	public static void output(String content) {
		try {
			FileWriter fw = new FileWriter(reportPath,true);
			fw.write(content);
			fw.close();
		} catch (IOException e) {
			System.out.println("writing failure" + e);
		}
	}


	/** Read the three .csv files, return a Sparse Matrix built from them*/
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static SparseMatrix readMatrix(String[] filePath) {

		// Create data structures for Sparse Matrix, being "value", "rowPtr", "colInd" respectively
		ArrayList<ArrayList> L = new ArrayList<ArrayList>();
		L.add(new ArrayList<Double>());
		L.add(new ArrayList<Integer>());
		L.add(new ArrayList<Integer>());

		try {
			// Each element in filePath[] corresponds to "value", "rowPtr", "colInd" respectively
			for(int i=0; i<L.size(); i++) {
				File file = new File(filePath[i]);
				if(file.isFile() && file.exists()) { 
					BufferedReader br = new BufferedReader(new FileReader(file));
					String line = null;

					// Iff current file is "value"
					if(i==0) while ((line = br.readLine()) != null) {L.get(i).add(Double.valueOf(line));}

					// Iff current file is "rowPtr", decrement by 1 to apply to class SparseMatrix
					else if(i==1) while ((line = br.readLine()) != null) {L.get(i).add(Integer.valueOf(line)-1);}

					// Iff current file is "colInd", decrement by 1 to apply to class SparseMatrix
					else while ((line = br.readLine()) != null) {L.get(i).add(Integer.valueOf(line)-1);}

					br.close();
				} else System.out.println("File doesn't exist!");
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		return new SparseMatrix(L.get(0), L.get(1), L.get(2));
	}
}
